---
title: "一起来学GO语言(2)--基础类型及变量"
description: ""
layout: post
date: 2015-12-19 20:22:10 +0800
categories: [编程]
tags: [go]
---

继第一个go语言程序之后，我们来看一看go语言中的基础类型，以及变量。


#三.变量及基础类型

##1.标识符
GO语言的标识符以一个非空的字母或数字串，其中第一个字符必须是字母，整个标示符也不能与关键字相冲突。字母可以是下划线`_`，或是Unicode编码分类中的任何字符。数字则是Unicode编码中`Nd`分类中的任何字符。

标识符区分大小写。

关于GO语言中的关键字，我们可以从官网的语言规范中查看[https://golang.irg/ref/spec#Keywords](https://golang.irg/ref/spec#Keywords)。

##2.基础类型
GO语言提供了丰富的基础类型供我们使用：

1. 布尔类型

		bool //值为true或false

2. 整数类型

		byte //等同uint8
		int //依赖于平台，32或64
		int8
		int16
		int32
		int64
		rune //等同于int32
		uint
		uint8
		uint16
		uint32
		uint64
		uintptr //容纳指针的无符号整数，与平台相关，uint32或uint64

3. 浮点数类型

		float32
		float64
		complex64 //实部和虚部都是float32
		complex128 //实部和虚部都是float64

4. 字符串类型

		string

这些基础类型比其他语言要丰富，比如JAVA，为我们提供了丰富的使用场景。


##3.变量及常量
1. 声明变量

	GO语言是一门非常智能的语言，表现在它可以进行类型推断，免去了类型声明。在声明一个变量时，我们可以使用以下几种方法：

		var a int
		var a int = 1
		var a = 1
		a := 1

	以上是4种声明方式：

	1）使用关键字`var`声明一个int类型的变量，其标识符为a。该变量没有被赋初值，因而GO会将其初始化为0以确保使用安全（**初值会根据其类型自动确定，数值类型为0，布尔类型为false，字符串为空字符串""**）。

	2）使用关键字`var`声明一个int类型的变量，其标识符为a，赋值为1。

	3）使用关键字`var`声明一个变量a，赋值为1.根据其值，GO语言会自动进行类型推断，将其类型置为int，以后不能被赋予其他类型的值（**类型推断的规则如下：整数推断为int，浮点数推断为float64，布尔为bool，字符串为string，带虚部的数为complex128**）。

	4）使用快速声明法`:=`声明变量a，并赋值1.类型推断与3）一致。

	注意：<font color=red>第四种快速声明法不能使用在函数体之外，GO规定在源代码结构中，函数外的所有语句都必须以关键字开始（如func、var、package等）</font>。

	上面所述的是变量声明规则，如果你需要声明多个变量，除了一个个声明外，还可以使用如下方法：

		var a,b = "123",2 //2个类型可以不一样，类型推断
		var a,b int = 1,2 //如果要加类型限定，只需要在最后加
		a,b := "123",2 //2个类型可以不一样，类型推断

2. 声明常量

	常量使用关键字`const`进行声明，与变量声明类似，但是常量不能使用快速声明法，也不能不赋初值：

		const A int = 1
		const B = 1

	如果要声明多个常量，可以一个个声明，也可使用如下方法：

		const (
			A = 0
			B int = 1
			C = "2"
		)

	在使用这种方法的时候，除了对每一个常量都赋值外，还有一些简便做法，如：

		const (
			A int = 1
			B
			C
		)

	这种方法的规则：

	1) 第一个常量必须赋值，其可被赋值为字符、数字、字符串、布尔或是`iota`

	2) 后续的常量，如果其没有被赋值，则其值与前一个常量相同。在上例中，A、B、C3个常量值相同，都为1.

	3) `iota`这个量在每一个const关键字里初值均为0，但会自增，比如下面这样的

		const (
			A = iota
			B
			C
		)

	根据规则2，A、B、C都是`iota`，但`iota`初值为0，并且递增，所以最终A、B、C的值为0、1、2

3. 变量的运算及使用		

	与其他语言一样，基础类型在GO语言中也可以进行各种各样的计算，比如比较运算、移位运算等。

	我把GO里的运算符列个表，大家看一下：

		//布尔运算
		!
		||
		&&
		<
		<=
		==
		!=
		>=
		>sd

		//算术运算符
		+
		-
		++
		--
		*
		/

		^
		%
		&
		|
		&^
		>>
		<<

	在进行运算的时候，需要注意的是，**GO语言要求操作数必须是相同类型的**（**字面值不受此限制**），与JAVA不同，GO并不会进行自动类型转换，如果操作数类型不一样，GO语言会报错。

	**类型转换**

	GO语言提供了一种机制来进行类型转换，以适应GO对运算操作的类型匹配要求。在GO中，我们可以用`Type(variable)`来进行类型转换，如：

		var a int = 1
		var b int64 = int64(a)

	当我们使用这种方法时，需要注意类型之间的值范围问题。当我们把低值转为高范围值的时候是不会出问题的，但如果把高范围的值转为低范围的值，则很有可能出问题，比如下面2种情况：

	1) int转int8（同类型转换）

	由于表示范围缩小了，会出现值丢失，可以自定义转换函数来进行转换

		func IntToInt8(v int) (int8, error) {
			if math.MinInt8 <= v && v <= math.MaxInt8 {
				return int8(v), nil
			}
			return -1, fmt.Errorf("%d is out of range", v)
		}

	2) float64转int (不同类型的转换)

	同样的，不同类型之间也会存在值范围缩小的问题，使得结果不可预期，也要自定义函数来进行转换

		func float64ToInt(v float64) (int, error) {
			if math.MinInt32 <= v && v <= math.MaxInt32 {
				whole, fraction := math.Modf(v)
				if(fraction >= 0.5){
					whole++
				}
				return int(whole), nil
			}
			return -1, fmt.Errorf("%g is out of range", v)
		}

	**相等比较**

	GO语言与其他语言一样，也不能避免浮点数的表示问题，在对浮点数进行相等比较运算时，会由于实际数值的不同而产生不符合预期的结果。

	例如0.0加上10个0.1、0.0加上5个0.2，结果是不相等的，要正确地比较2个浮点数，可以自定义函数如：

		//提供精度参数
		func floatEqual(x,y float64, decimals int) bool {
			a := fmt.Sprintf("%.*f", decimals, x) //转换为字符串
			b := fmt.Sprintf("%.*f", decimals, y)
			return len(a) == len(b) && a==b
		}
